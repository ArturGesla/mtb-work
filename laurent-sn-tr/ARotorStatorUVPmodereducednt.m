%
% Contin = 0 starts from X = 0
%        = 1 starts from previous Xsav.mat
%        = 2 starts from XsavRayXXX_mesh.mat + amplitudeig*EigVpReXXX_mesh.mat
%
tolRHS = 0; %1.e-9
Prdtl = 0.71;
% Loading Numerical Functions generated by Symbolic computations done by GenerateSymbolNavierStokes.m
%load('SymbolicNSCavitDiffT_nt1.mat')
% load('SymbolicNSCavitDiffTTranspose_nt1.mat')
load('SymbolicNSCavitDiffTTranspose_nt3.mat')
% Contin.   Ray  itnewtmax  eigcomput shift_i nev  amplitudeig
 paramstab = [...
%     0        20000     8          0      0.1    100    0.05;...
    1       100000     8          0      0.1    100    0.05;...
%     1       500000     8          0      0.1    100    0.05;...
%     1      1000000     8          0      0.1    100    0.05;...
%      1        2.1e6        8          0     2.0    100    0.05;...
%        1      2.3e6     8          0      2.    100     0.05;...
%        1      2.4e6     8          0      2.    100     0.05;...
%     1      2.5e6     8          0      2.0    100    0.05;...
%     1      2.6e6     8          0      2.0    100    0.05;...
%     1      2.7e6     8          0      2.0    100    0.05;...
%     1      2.8e6     8          0      2.0    100    0.05;...
%     1      2.9e6     8          0      2.0    100    0.05;...
%      1      3.0e6     8          1      2.0    100    0.05;...
%     1      3.2e6     8          1      2.0    100    0.05;...
%     1      3.4e6     8          1      2.0    100    0.05;...
%     1      3.6e6     8          1      2.0    100    0.05;...
%     1      3.8e6     8          1      2.0    100    0.05;...
%     1      4.0e6     8          1      2.0    100    0.05;...
%     1      4.2e6     8          1      2.0    100    0.05;...
%     1      4.4e6     8          1      2.0    100    0.05;...
%     1      4.6e6     8          1      2.0    100    0.05;...
%     1      4.8e6     8          1      2.0    100    0.05;...
%     1      5.0e6     8          1      2.0    100    0.05;...
%     1      5.2e6     8          1      2.0    100    0.05;...
%     1      5.4e6     8          1      2.0    100    0.05;...
%     1      5.6e6     8          1      2.0    100    0.05;...
%     1      5.8e6     8          1      2.0    100    0.05;...
%     1      6.0e6     8          1      2.0    100    0.05;...
%     1      6.5e6     8          0      2.0    100    0.05;...
%     1      7.0e6     8          0      2.0    100    0.05;...
%     1      7.5e6     8          0      2.0    100    0.05;...
%     1      8.0e6     8          0      2.0    100    0.05;...
%     1      8.5e6     8          0      2.0    100    0.05;...
%     1      9.0e6     8          0      2.0    100    0.05;...
%     1      9.5e6     8          0      2.0    100    0.05;...
%     1      1.00e7     8          0      2.0    100    0.05;...
%     1      1.05e7    8          0      2.0    100    0.05;...
%     1      1.10e7     8          0      2.0    100    0.05;...
%     1      1.15e7    8          0      2.0    100    0.05;...
%     1      1.20e7     8          0      2.0    100    0.05;...
%     1      1.25e7    8          0      2.0    100    0.05;...
%     1      1.30e7     8          0      2.0    100    0.05;...
%     1      1.35e7    8          0      2.0    100    0.05;...
%     1      1.40e7    8          0      2.0    100    0.05;...
%     1      1.45e7    8          0      2.0    100    0.05;...
%     1      1.50e7    8          0      2.0    100    0.05;...
%     1      3.e6     8          1      2.    100     0.05;...
%     1      3100     8          1      0.1    100     0.05;...
 %    1      4.e6     8          1      3.    100     0.05;...
     ];

% Loading Numerical Functions generated by Symbolic computations done by GenerateSymbolNavierStokes.m
%load('SymbolicNSCavitDiffT_nt2.mat')
%load('SymbolicNSCavitDiffT_nt3.mat')
%load('SymbolicNSCavitDiffTTranspose_nt3.mat')
%load('SymbolicNSCavitDiffT_nt4.mat')
%load('SymbolicNSCavitDiffT_nt5.mat')
% Contin.   Ray  itnewtmax  eigcomput shift_i nev  amplitudeigformat long

%             paramstab = [...
%                2       3.0000000e6     9          0      2.0    100    0.1;...
%                ];
% % 
%Contin.   Ray  itnewtmax  eigcomput shift_i nev  amplitudeig
% paramstab = [...
%     1      2.5e6     8          0      2.0    100    0.05;...
%     1      2.6e6     8          0      2.0    100    0.05;...
%     1      2.7e6     8          0      2.0    100    0.05;...
%     1      2.8e6     8          0      2.0    100    0.05;...
%     1      2.9e6     8          0      2.0    100    0.05;...
%     1       3.e6     8           0      0.1    20    0.05;...
%     1      3.2e6     8          0      2.0    100    0.05;...
%     1      3.4e6     8          0      2.0    100    0.05;...
%     1      3.6e6     8          0      2.0    100    0.05;...
%     1      3.8e6     8          0      2.0    100    0.05;...
%     1      4.0e6     8          0      2.0    100    0.05;...
%     1      4.2e6     8          0      2.0    100    0.05;...
%     1      4.4e6     8          0      2.0    100    0.05;...
%     1      4.6e6     8          0      2.0    100    0.05;...
%     1      4.8e6     8          0      2.0    100    0.05;...
%     1      5.0e6     8          0      2.0    100    0.05;...
%     1      5.2e6     8          0      2.0    100    0.05;...
%     1      5.4e6     8          0      2.0    100    0.05;...
 %    1       7.0e6     8          0      2.0    100    0.05;...
% %    1      2900     8          0      0.1    100    0.05;...
% %    1      3000     8          0      0.1    100    0.05;...
% %    1      3100     8          0      0.1    100    0.05;...
% %     1      4400     8          0      0.1    100    0.05;...
% %     1      4600     8          0      0.1    100    0.05;...
% %     1      4700     8          0      0.1    100    0.05;...
% %    1      4750     8          0      0.1    100    0.05;...
% %     1      4900     8          0      0.1    100    0.05;...
% %     1      5000     8          0      0.1    100    0.05;...
% %     1      3200     8          0      0.1    100    0.05;...
% %     1      3300     8          0      0.1    100    0.05;...
% %     1      3400     8          0      0.1    100    0.05;...
% %     1      3500     8          0      0.1    100    0.05;...
% %     1      3600     8          0      0.1    100    0.05;...
% %     1      3700     8          0      0.1    100    0.05;...
% %     1      3800     8          0      0.1    100    0.05;...
% %     1      3000     8          0      0.1    100    0.05;...
% %      1      3900     8          0      0.1    100    0.05;...
% %      1      4000     8          0      0.1    100    0.05;...
% %      1      4100     8          0      0.1    100    0.05;...
% %      1      4200     8          0      0.1    100    0.05;...
% %      1      4300     8          0      0.1    100    0.05;...
% %     1      4400     5          0      0.1    100    0.05;...
% %     1      4500     5          0      0.1    100    0.05;...
%  %    1      4600     5          0      0.1    100    0.05;...
  %  ];
% % 
% 
%  Retab  = [20 200 500 1000 1500 2000 2500 2700 ];
%  paramstab = [ones(size(Retab')) Retab' 8*ones(size(Retab')) ...
%               zeros(size(Retab')) zeros(size(Retab')) zeros(size(Retab')) ...
%               zeros(size(Retab'))];
%  paramstab(1,1) = 0; % to set continuation to False for the first run

paramstab
%return
%% Grid generation
rereadgrid = false; % Reread grid generated by Meshgen
if rereadgrid
    % Reading grid from meshgen generated files.
    geo.A = 0; geo.C = 0;
    disp(' Reading meshgen files ')
    %geo.xu = load('sunfluidh/maillx.d');
    %geo.yv = load('sunfluidh/mailly.d');
    geo.yv = load('sunfluidh/maillx.d');
    geo.xu = load('sunfluidh/mailly.d');
    geo.xu(:,1) =[];
    geo.yv(:,1) = [];
    geo.xu = [geo.A (geo.A+geo.xu')];
    geo.yv = [geo.C (geo.C+geo.yv')];
    nx = length(geo.xu)+1;
    ny = length(geo.yv)+1;
else
    geo.A  = 0; geo.B = 1.; geo.C = 0; geo.D = 1.0;
    %Uniform grid
    disp('Regular grid ')
    nx = 64;  nx  = nx + 2; % 
    ny = 64;   ny = ny + 2; %
    nx = 3;  nx  = nx + 2; % 
    ny = 2;   ny = ny + 2; %
    geo.xu = linspace(geo.A,geo.B,nx-1);
    geo.yv = linspace(geo.C,geo.D,ny-1);
   % geo.xu = (1.0-cos(geo.xu*pi))/2; disp(' Cosine grid xu')
   % geo.yv = (1.0-cos(geo.yv*pi))/2; disp(' Cosine grid yv')

    %     % Nonuniform grid
    %      disp(' Nonuniform grid')
    %      %geo.xu = (1-cos(geo.xu*pi))/2; disp(' Cosine grid ')
    %
    %      geo.xu = [geo.A ...
    %                cumsum([ ...
    %                        regular(8.,700) ...
    %                        tanh2s(2,1024-700,8/700,8/700/4)...
    %                       ])];
    %      geo.yv = [geo.C cumsum( tanh2s(geo.D-geo.C,192,2.e-3,2.e-3) ) ];
    %
    %      geo.xu = [geo.A ...
    %                cumsum([ ...
    %                        regular(8.,400) ...
    %                        tanh2s(2,200,8/400,8/400/4)...
    %                       ])];
    %      geo.yv = [geo.C cumsum( tanh2s(geo.D-geo.C,160,3.e-3,3.e-3) ) ];

    nx = length(geo.xu)+1;
    ny = length(geo.yv)+1;
end

% Deduce xc yc from xu and yv
geo.xc = [(3*geo.xu(1)-geo.xu(2))/2 (geo.xu(2:nx-1)+geo.xu(1:nx-2))/2  (3*geo.xu(nx-1)-geo.xu(nx-2))/2  ];
geo.yc = [(3*geo.yv(1)-geo.yv(2))/2 (geo.yv(2:ny-1)+geo.yv(1:ny-2))/2  (3*geo.yv(ny-1)-geo.yv(ny-2))/2  ];

% Add local variables to structure geo.
geo.nx = nx; geo.ny=ny;

% Build param vectors from geometry
xparams = [geo.xc geo.xu];
yparams = [geo.yc geo.yv];

%return

%% Start Loops
for iloop  =  1:size(paramstab,1)

    continuation      = paramstab(iloop,1);
    Ray               = paramstab(iloop,2);
    itnewtonmax       = paramstab(iloop,3);
    eigcomput         = paramstab(iloop,4);
    sigma             = paramstab(iloop,5);
    nev               = paramstab(iloop,6);
    amplitudeig       = paramstab(iloop,7);

    %
    if nt>1
        ndim = nx*ny*nvar*2*nt+1;   % The '2' comes from nt real + nt imag
        nbRHS = 1;
    else
        ndim = nx*ny*nvar*2;  % It includes an imag part for consistancy
        nbRHS = 1;
    end
    %but
    % I create a special vector to remove imaginary part in the matrix before solving
    % Pick only real values nvar values every 2*nvar;
    PickOnlyReal = 1:(ndim-mod(1,nt))/nt;
    PickOnlyReal = reshape(PickOnlyReal,nvar,[]);
    PickOnlyReal(:,2:2:end) = []; %remove nodes with the imag part
    PickOnlyReal = PickOnlyReal(:);
    ks =  0:(nt-1); % Spectral modes in "academic" ordering
    prob.nvar = nvar; prob.Ray= Ray;


    %% Stencil, Stencils and Nodes locations.

    % Stencils definitions
    stencil1v = [ (-1+nx)   nx   (+1+nx) ...
        -1      0      +1    ...
        (-1-nx)  -nx   (+1-nx)     ];

    stencil1v = stencil1v*nvar*2*nt; % Spacing by nvar*2*nt everywhere in the stencil
    lst = length(stencil1v);

    stencilntv = zeros(1,lst*2*nt);

    for k = 1:2*nt
        stencilntv(k:2*nt:(lst*2*nt + k-1 ) ) = (stencil1v + (k-1)*nvar) ;
    end

    stencils = stencilntv;
    for nv = 1:nvar-1
        stencils = [stencils (stencilntv+nv)];
    end

    xstencil = [-1 0 1 (nx-1) nx (nx+1)];
    ystencil = [-1 0 1 (ny-1) ny (ny+1)]; % must match extra_vars, xparams and yparams

    if nt>1
        fixedloc = [ndim];   % For Fq  with fixed position in the Jacobian.
    else
        fixedloc = [];
    end
    %
    fixedparams = [Prdtl/sqrt(Ray) 1/sqrt(Ray) Prdtl] ;    % must match extra_params,
    paramstencil = 1:length(fixedparams);


    %% Nodes
    allnodes = reshape(0:nvar:nvar*2*nt*nx*ny-1,2*nt,nx,ny); %
    % U Nodes
    Uvarpos = 1; % Variable position
    UNorthNodes =         allnodes(:,1:nx-1,ny    )                   + Uvarpos;
    UWestNodes  = squeeze(allnodes(:,1     ,2:ny-1))                  + Uvarpos;
    UCoreNodes  = reshape(allnodes(:,2:nx-2,2:ny-1),2*nt,(nx-3)*(ny-2)) + Uvarpos;
    UEastNodes  = squeeze(allnodes(:,nx-1  ,2:ny-1))                  + Uvarpos;
    USouthNodes =         allnodes(:,1:nx-1,1     )                   + Uvarpos;
    UFakeNodes  = squeeze(allnodes(:,nx    ,1:ny  ))                  + Uvarpos;

    % V Nodes
    Vvarpos = 2; % Variable position
    VNorthNodes =         allnodes(:,2:nx-1,ny-1  )                   + Vvarpos;
    VWestNodes  = squeeze(allnodes(:,1     ,1:ny-1))                  + Vvarpos;
    VCoreNodes  = reshape(allnodes(:,2:nx-1,2:ny-2),2*nt,(nx-2)*(ny-3)) + Vvarpos;
    VEastNodes  = squeeze(allnodes(:,nx    ,1:ny-1))                  + Vvarpos;
    VSouthNodes =         allnodes(:,2:nx-1,1     )                   + Vvarpos;
    VFakeNodes  =         allnodes(:,1:nx  ,ny    )                   + Vvarpos;

    % P nodes
    Pvarpos = 3; % Variable position
    PNWNodes    =         allnodes(:,1     ,ny    )                   + Pvarpos;
    PNorthNodes =         allnodes(:,2:nx-1,ny    )                   + Pvarpos;
    PNENodes    =         allnodes(:,nx    ,ny    )                   + Pvarpos;
    PWestNodes  = squeeze(allnodes(:,1     ,2:ny-1))                  + Pvarpos;
    PCoreNodes  = reshape(allnodes(:,2:nx-1,2:ny-1),2*nt,(nx-2)*(ny-2)) + Pvarpos;
    PEastNodes  = squeeze(allnodes(:,nx    ,2:ny-1))                  + Pvarpos;
    PSWNodes    =         allnodes(:,1     ,1     )                   + Pvarpos;
    PSouthNodes =         allnodes(:,2:nx-1,1     )                   + Pvarpos;
    PSENodes    =         allnodes(:,nx    ,1     )                   + Pvarpos;
    PcteNodes    = PCoreNodes(:,1); PCoreNodes(:,1) = [];  % node to set P=cte
    % All Fourier modes are set to zero for one specific spatial point.

    % W nodes
    Wvarpos = 4; % Variable position
    WNWNodes    =         allnodes(:,1     ,ny    )                   + Wvarpos;
    WNorthNodes =         allnodes(:,2:nx-1,ny    )                   + Wvarpos;
    WNENodes    =         allnodes(:,nx    ,ny    )                   + Wvarpos;
    WWestNodes  = squeeze(allnodes(:,1     ,2:ny-1))                  + Wvarpos;
    WCoreNodes  = reshape(allnodes(:,2:nx-1,2:ny-1),2*nt,(nx-2)*(ny-2)) + Wvarpos;
    WEastNodes  = squeeze(allnodes(:,nx    ,2:ny-1))                  + Wvarpos;
    WSWNodes    =         allnodes(:,1     ,1     )                   + Wvarpos;
    WSouthNodes =         allnodes(:,2:nx-1,1     )                   + Wvarpos;
    WSENodes    =         allnodes(:,nx    ,1     )                   + Wvarpos;

    % Fqnode
    if nt>1
        FqNode = ndim;  %
        % Pick some location for phase condition. We assume U as variable
        r_phase = 0.5;
        z_phase = 0.9;
        [~, ix_phase] = min( abs(geo.xu-r_phase) );
        [~, jy_phase] = min( abs(geo.yc-z_phase) );
        PhaseNode = 1+((ix_phase-1-1) + (jy_phase-1-1)*(nx-3))*2*nt;
    else
        FqNode = 0; % just to generate an error
    end
    clear allnodes % to save some memory.
    % Make a list with all nodes (Check coherence with Equations list in GenerateSymbolicNavierStokes.m
    %                             The order of Nodes must match the order of Equations)
    Nodes     =   {...
        UNorthNodes, ...
        UWestNodes,  UCoreNodes,  UEastNodes, ...
        USouthNodes,...
        UFakeNodes,...
        VNorthNodes, ...
        VWestNodes,  VCoreNodes,  VEastNodes,...
        VSouthNodes,...
        VFakeNodes, ...
        PNWNodes,    PNorthNodes,    PNENodes,   ...
        PWestNodes,  PCoreNodes,     PEastNodes, ...
        PSWNodes,    PSouthNodes,   PSENodes,    ...
        PcteNodes, ...
        WNWNodes,    WNorthNodes,    WNENodes,   ...
        WWestNodes,  WCoreNodes,     WEastNodes, ...
        WSWNodes,    WSouthNodes,    WSENodes,    ...
        FqNode ...
        };
    if nt==1
        Nodes(end)=[]; % remove last element FqNode
    end
    %%
    % Reorganize Nodes for loop efficiency and for coherence with the number of Equations
    % This is because we have more Equations than list of Nodes
    % Certainly a smarter way to do this....

    % Note: mod(1,nt) = 0 if nt=1 and 1 otherwise

    neq2nodes = [reshape((1:(nbEquations-mod(1,nt))/(2*nt)).*ones(2*nt,1),1,(nbEquations-mod(1,nt))), ((nbEquations-mod(1,nt))/(2*nt) + mod(1,nt))];
    Nodestempo = cell(1,nbEquations);
    for neq = 1:nbEquations
        k = mod(neq-1,2*nt) + 1;
        Nodestempo{neq} =  Nodes{neq2nodes(neq)}(k,:);
    end
    Nodes = Nodestempo;

    %return

    %% Start Computations
    % Initial vector
    switch continuation
        case 0
            X = zeros(ndim,1);
        case  1
            load('Xsav.mat')
            disp('Reading XSav for continuation')
        case 2
            % We assume here that nt >1
            if nt == 1
                error('nt = 1 and you try to find an UPO')
            end
            Xinter = zeros(nvar,2*nt*nx*ny);
            load(strcat('XsavRay',num2str(Ray),'_',num2str(nx-2),'x',num2str(ny-2),'.mat')) %
            load(strcat('EigRay',num2str(Ray),'_',num2str(nx-2),'x',num2str(ny-2),'.mat')) %
            disp(['Reading baseflow and eigenmodes for Re =  ',num2str(Ray)])
            Fqguess = 1.*imag(eigvalp)/(2*pi);
            % Shift the eigenvector to have the phase = 0 for U on one grid point
            % UCoreNodes(1) is where this condition is set.
            Vpins = amplitudeig*norm(X)*Vpins.*exp(-1j*angle(Vpins( (UCoreNodes(PhaseNode)-1)/2/nt + 1 ) ) );
            %Vpins = amplitudeig*norm(X)*Vpins.*exp(-1j*angle(Vpins( 1+((ix_phase-1) +(jy_phase-1)*nx)*nvar ))); % same as above.

            Xinter(:,(0+1)   :2*nt:end)   =  reshape(X(PickOnlyReal),nvar,nx*ny); % get the mean k=0;
            %Xinter(:,(0+1)+nt:2*nt:end)   = 0  % fake imag part of mean (k=0 i.e. baseflow)
            Xinter(:,(1+1)   :2*nt:end)   =  reshape(real(Vpins),nvar,nx*ny); % fill for k=+1;
            Xinter(:,(1+1)+nt:2*nt:end)   =  reshape(imag(Vpins),nvar,nx*ny); % fill for k=+1;
            X = ([reshape(Xinter,1,nvar*2*nt*nx*ny) Fqguess]).';

            clear Xinter  % to save memory

        otherwise
            error('Problem with continuation switch')

    end

    %
    for itnewton = 1:itnewtonmax


        %%  Preallocate arrays for Sparse Matrix (It is necessary for large matrix)
        mynnz = 10*2*nt*ndim; % This estimation can be improved later with an exact count
        JacI = zeros(mynnz,1);
        JacJ = zeros(mynnz,1);
        JacV = zeros(mynnz,1);
        % %
        RHS  = zeros(ndim,1);
        % %

        disp(' ');
        disp('-----------------------------------------------------------------------');
        disp(['Newton iter # ',num2str(itnewton),' Solving for Ray = ',num2str(Ray)])
        disp(' ');
       tic

        ind_start = 1;
        % Fill the matrix

        for neq = 1:nbEquations
            % Pick the handle function from the list generated with
            % GenerateSymbolNavierStokes.m
            f  = listF{neq};
            df = listdF{neq};

            % Variables to evaluate once for each neq and save cpu-time
            jcolstencil = stencils(jcoleqv{neq});
            jcolfixed   = fixedloc(jcoleqf{neq});
            nbjcol = length(jcolstencil) + length(jcolfixed);
            xusedstencil = xstencil(xusedparam{neq});
            yusedstencil = ystencil(yusedparam{neq});
            fparam       = fixedparams(paramstencil(usedparam{neq}));

            for ieq = Nodes{neq}
                [ix,jy,nv,k] = ieq2ind(ieq,nvar,nx,nt); % get indices
                jcolv = jcolstencil + ieq - (nv-1) - (k-1)*nvar; % get columns to be filled
                jcolf = jcolfixed;
                jcol = [jcolv jcolf];
                if (nt>1) && (ieq == ndim) % super dirty trick to set the phase condition !!!
                    jcol = UCoreNodes(PhaseNode -1 + (1:2*nt)); % we do not have a specific stencil for EqFq equation.
                    jcol(1:nt) = []; % Remove real nodes
                    jcol(1) = [];    % then remove imag of k=0 mode.
                end
                Xjcol = X(jcol).'; % get the corresponding values from X
                params = [xparams(ix+xusedstencil) yparams(jy+yusedstencil) fparam]; % get


                % Filling the ieq line of the matrix and RHS
                ind = ind_start : ind_start + nbjcol-1;

                JacI(ind) = ieq;
                JacJ(ind) = jcol;
                JacV(ind) =  df([Xjcol,params]);
                RHS(ieq)  = -f([Xjcol,params]);

                ind_start = ind_start + nbjcol;
            end
        end

        t=toc;
        disp(['Computing Matrix and RHS ... ',num2str(t),' sec.']);
        %%
        residualRHS = sum(abs(RHS));
        disp(['                          Sum RHS  =   ',num2str(residualRHS)])
        if nt > 1
            disp(['                   RHS for EqFreq  =   ',num2str(abs(RHS(ndim)))])
        end
        %% Create sparse matrix
        tic

        tabelim = JacI==0;
        JacV(tabelim)=[];
        JacI(tabelim)=[];
        JacJ(tabelim)=[];
        clear tabelim
        disp(['Length Jacv removing zero JacI ', num2str(length(JacV))])
        SA1 = sparse(JacI,JacJ,JacV);

        tabelim  = abs(JacV)<1e-7;
        tabelim2  = abs(JacV)<1e-10;
        JacJ2 = JacJ;
        JacV(tabelim)=[];
        JacI(tabelim)=[];
        JacJ(tabelim)=[];
        clear tabelim
        disp(['Length Jacv removing small coeff ', num2str(length(JacV))])


        SA = sparse(JacI,JacJ,JacV);
        if nt==1
            SA = SA(PickOnlyReal,PickOnlyReal);
            RHS = RHS(PickOnlyReal);
        end
        [JacI,JacJ,JacV] = find(SA); % extract only the non zeros elements from SA.
        t=toc;
        disp(['Creating Sparse matrix ... ',num2str(t),' sec.']);

        if nt>1
            % %% Save SA and RHS for external solver.
            % Binary format
            tic
            fileID = fopen('matdim.bin','w');
            fwrite(fileID,size(SA,1),'int');
            fwrite(fileID,length(JacI),'int');
            fwrite(fileID,nbRHS,'int');
            fwrite(fileID,JacI,'int');
            fwrite(fileID,JacJ,'int');
            fwrite(fileID,JacV,'real*8');
            fwrite(fileID,RHS,'real*8');
            fclose(fileID);
            t = toc;
            disp(['Writing the matrix to the disk ... ',num2str(t),' sec.']);
        end
        %clear JacI JacJ JacV tabelim dX  % save memory
        if residualRHS < tolRHS
            break
        end        
        %% Solvers

        tic
        % Direct method Matlabe Solver
        % No control
         if nt == 1
             dX = SA\RHS;
         end
        % Storing L and U a bit slower than above ! (?)
        %    [L,U,P,Q,D] = lu(SA);
        %    dX= Q * (U \ (L \ (P * (D \ RHS))));
        % [L,U,P,Q,R] = umfpack2(SA) ;
        % dX= Q * (U \ (L \ (P * (R \ RHS)))) ;

        %  External solver Pardiso/Mumps
       %      clear SA
       %     
         if nt > 1
             % binary style pardiso will read matdim.bin
          %   !pardisoreal
          %   dX = load('fort.78');
             % binary style mumps will read matdim.bin
              !mumpsrealbinary
              dX = load('fort.78');
              % dX    = dXtot(1:ndim);
              %              dX2   = dXtot(ndim+1:nbRHS*ndim);
        %       dX = 0
         end
        % disp(['Norm dX-dX1  = ',num2str(norm(dX2-dX))])
        % pause

        % Iterative methods
        %     [L,U] = ilu(SA,struct('type','ilutp','droptol',1e-6));
        %     t=toc;
        %     disp(['Preconditionning ... ',num2str(t),' sec.']);
        %     tic
        %     dX = gmres(SA,RHS,5,1.e-8,20,L,U);
        t=toc;
        disp(['Solving System ... ',num2str(t),' sec.']);

        if nt==1
            X(PickOnlyReal) = X(PickOnlyReal)+dX;
        else
            X = X+dX;
        end
        residualdX = sum(abs(dX)); 
        disp(['                          Sum dX   =   ',num2str(residualdX)])

        %% Visualisation

        Xinter = reshape(X(1:ndim-mod(1,nt)),nvar,[]);

        Xm0 = reshape(Xinter(:,1:2*nt:end),nvar*nx*ny,1);
        reshapeplot(Xm0,geo,prob,1); % baseflow on fig 1
        if nt>1
            for ind = 2:nt
                Xm1r = reshape(Xinter(:,ind:2*nt:end),nvar*nx*ny,1);
                Xm1i = reshape(Xinter(:,nt+ind:2*nt:end),nvar*nx*ny,1);
                reshapeplot(Xm1r,geo,prob,2*(ind-1)+1); % Real part of k=1 on fig 3,5,7...
                reshapeplot(Xm1i,geo,prob,2*(ind-1)+2); % Imag part of k=1 on fig 4,6,8...
                disp(['Norm for mode  ', num2str(ind-1),' = ',  num2str(norm(Xm1r+1i*Xm1i))  ] )
            end
            disp(['Freq = ' num2str(X(ndim))  '   Period = ' num2str(1/X(ndim)) ] )
        end
        %
        clear Xinter Xm0 Xm1r Xm1i

    end % Newton iteration
    %%
    save('Xsav.mat','X','residualdX')
    if nt==1
        save(strcat('XsavRay',num2str(Ray),'_',num2str(nx-2),'x',num2str(ny-2),'.mat'),'X','geo','prob','residualdX','residualRHS');
    else
        save(strcat('XsavRay',num2str(Ray),'_',num2str(nx-2),'x',num2str(ny-2),'BigUPO.mat'),'X','geo','prob','residualdX','residualRHS');        
    end

    %% Compute eigen modes if asked.
    if eigcomput
        % Building the matrix B for LSA or Hill's method: A*x = lbda*B x

                % Building the matrix B for LSA or Hill's method: A*x = lbda*B x
        %
        if nt == 1
            ndimr= ndim
        else
            ndimr= ndim-1 % remove the Freq equation
        end
        SB_d = zeros(ndimr,1);
        if nt == 1
            SB_d([UCoreNodes VCoreNodes WCoreNodes]) = -1; % List Nodes with time dependence
            SB = spdiags(SB_d,0,ndimr,ndimr);
            SB = SB(PickOnlyReal,PickOnlyReal); % get only the real part Only for nt=1
        else
            SB_d([UCoreNodes([1:nt (nt+2):2*nt],:) VCoreNodes([1:nt (nt+2):2*nt],:) WCoreNodes([1:nt (nt+2):2*nt],:)]) = -1; % List Nodes with time dependence
            SB = spdiags(SB_d,0,ndimr,ndimr);
        end
        clear SB_d
        %
%         if nt == 1
%             ndimr= ndim
%         else
%             ndimr= ndim-1 % remove the Freq equation
%         end
%         SB_d = zeros(ndimr,1);
%         SB_d([UCoreNodes VCoreNodes WCoreNodes]) = -1; % List Nodes with time dependence
%         SB = spdiags(SB_d,0,ndimr,ndimr); clear SB_d
%         if nt == 1
%             SB = SB(PickOnlyReal,PickOnlyReal); % get only the real part Only for nt=1
%         end
        disp(' ');
        disp('Start solving  A*x = lbda*B*x ')
        %nev = 100; is defined in paramtab
        sigma_i = sigma*1i; %sigma is defined in paramtab
        disp([num2str(nev), ' eigenvalues asked with a shift ',num2str(sigma_i)])
        tic
        if nt == 1
            [Vp lbda] = eigs(SA,SB,nev,sigma_i);   
            lbda = diag(lbda)
        else
            lbda = eigs(SA(1:end-1,1:end-1),SB,nev,sigma_i);
        end
        figure(2*nt)
        %plot(lbda,'go')
        plot(lbda,'o')
        hold on
        t=toc;            
        disp(['Solved in  ... ',num2str(t),' sec.']);
        if nt==1
            kind = find(real(lbda)==max(real(lbda)))
            kind = 12
            warning(strcat('K = ',num2str(kind)))
            plot(lbda(kind),'ro','markersize',14)

            Vpins = Vp(:,kind);
            eigvalp  = lbda(kind);
            filename = strcat('EigRay',num2str(Ray),'_',num2str(nx-2),'x',num2str(ny-2),'.mat');
            save(filename,'Vpins','eigvalp','lbda','geo','prob','sigma_i','residualdX','residualRHS')
        end
    end


end
