function [field]=read_sunfluidh_data(varargin)
%READ_SUNFLUIDH_DATA read data generated by sunfluidh
%   F = READ_SUNFLUIDH_DATA() returns in the structure F
%   the fields from the last res_00000_*.d file generated
%   by sunfluidh and verbose details.
%
%   F = READ_SUNFLUIDH_DATA(N) returns in the structure F
%   the fields from the res_00000_N.d file. 
%
%   F = READ_SUNFLUIDH_DATA(N,K) returns in the structure F
%   the fields from the res_K_N.d file. 
%
%   F = READ_SUNFLUIDH_DATA('stat') returns in the structure F
%   the fields from the last rst_00000_*.d file generated
%   by sunfluidh and verbose details.
%
%   F = READ_SUNFLUIDH_DATA(N,'stat') returns in the structure F
%   the statistic fields from the rst_00000_N.d file. 
%
%   F = READ_SUNFLUIDH_DATA(N,K,'stat') returns in the structure F
%   the statistic fields from the rst_K_N.d file. 
%
%   F = READ_SUNFLUIDH_DATA('slice') returns in the structure F
%   the fields from the last slice_*_*_00000_*.d file generated
%   by sunfluidh and verbose details.
%
%   F = READ_SUNFLUIDH_DATA('slice',L,M) returns in the structure F
%   the fields from the last slice_M_L_00000_*.d file. L is
%   the direction normal to the slice, M specifies the slice number.
%
%   F = READ_SUNFLUIDH_DATA(N,'slice') returns in the structure F
%   the fields from the last slice_*_*_00000_N.d file.
%
%   F = READ_SUNFLUIDH_DATA(N,K,'slice') returns in the structure F
%   the fields from the last slice_*_*_K_N.d file.
%
%
%   Use option 'center' to interpolate the staggered fields on grid nodes
%   Use option 'verbose' to obtain informations on the file you read 

% Written by L. Martin Witkowski witko@limsi.fr
% 21/06/2013
%
% Revision 16/01/2014 :
% Introduce nested function cent2stag and output staggered grid
%
% Revision 24/01/2014
% Now read 'rst' files 

% Revision 30/01/2014
% Add the possibility to center the fields and internal reorganization
% of the way to read all the arguments.

% Revision 08/12/2015
% kle_ch tests are more robust for staggered grid.
% Reynolds and Rayleigh are no longer an output as it is
% more relevant to read the namelist directly with
% read_sunfluidh_namelist

% Minor change 04/01/2016
% Bug removed for the axisymmetric case for W component

% Bugs fix 19/02/2016
% Read again variable names longer than 1 letter. This bug was 
% introduced by the 04/01/2016 changes!
% kle_ch is now forced to be logical. It seemed to behave strangely with
% single precision field set on. It was reading -1 instead of 1 
% (fortran bug ?!)
% 

% Add the possibility to read slice 11/09/2017 slice was called formerly
% plan
% 

% Revised to include version 3 of sunfluidh's output 23/04/2019
% kle_ch is removed. I hope this is not a problem.
%


varargincopy = varargin;

%--- Default values
NbArgNum = 0;
NbArgNumslice = 0;
ranknb = 0;  %
dir_slice = 1;
num_slice = 1;

filename_start ='res';  % 'rst' ,'slice'
centered = false; Do_centering = false;
verbose = true;

%--- Loop over the arguments to change the default values
while ~isempty(varargincopy);
    if isnumeric(varargincopy{1});
        NbArgNum = NbArgNum+1;
        verbose = false;
        switch NbArgNum
            case 1 % First numerical argument is ind
                ind = varargincopy{1};
                varargincopy(1) =[];
            case 2 % Second numerical argument is ranknb
                ranknb = varargincopy{1};
                varargincopy(1) =[];
            otherwise
                help read_sunfluidh_data
                error('Too many numerical arguments')
        end
    else
        switch lower(varargincopy{1}) % Make sure it is lowercase
            case 'stat'
                filename_start = 'rst';
                centered = true; % by default stat fields are centered
                varargincopy(1) = [];
            case 'slice'
                filename_start = 'slice'; 
                centered = true; % by default slice fields are centered
                varargincopy(1) = [];
                % Continue reading numerical parameters (if any)
                if ~isempty(varargincopy);
                    if isnumeric(varargincopy{1});
                        NbArgNumslice = 2;
                        % First numerical argument is direction normal to slice
                        dir_slice = varargincopy{1};
                        varargincopy(1) =[];
                        % Second numerical argument is number of slice
                        if isempty(varargincopy)
                            help read_sunfluidh_data
                            error('option ''slice'' needs 2 numerical arguments')
                        else
                            num_slice = varargincopy{1};
                            varargincopy(1) =[];
                        end
                    end
                end
                
            case 'center'
                Do_centering = true;
                varargincopy(1) = [];
            case 'verbose'
                verbose = true;
                varargincopy(1) = [];
            otherwise
                help read_sunfluidh_data
                error('Unknown argument : %s \n', varargincopy{1})
        end
    end
end

if NbArgNum == 0
    % here we assume the user wants to read the "last"
    % res, rst or slice file generated
    switch filename_start
        case {'res', 'rst'}
            [~,liste]=eval(['unix(''ls -1 ' filename_start '_?????_???????.d'')']);
            filename = liste(end-(16+length(filename_start)):end-1);
            % 16 comes from 1 + 5 + 1 + 7 + 2 characters
        case 'slice'
            if NbArgNumslice == 0
                [~,liste]=eval(['unix(''ls -1 ' filename_start '_??_?_?????_???????.d'')']);
                filename = liste(end-(21+length(filename_start)):end-1);
            else
                [~,liste]=eval (sprintf( ['unix(''ls -1 ' ... 
                    filename_start '_' '%02i' '_' '%1i' '_?????_???????.d'')'],num_slice,dir_slice ) );
                filename = liste(end-(21+length(filename_start)):end-1);                
            end
    end
    clear(liste);
    verbose=true;
else
    switch filename_start
        case {'res' , 'rst'}
            %--- Set the file name from ind, rank and filenamestart
            filename = sprintf( [filename_start '_' '%05i' '_' '%07i' '.d'],ranknb,ind);
        case 'slice'
            if NbArgNumslice == 0
                [~,liste]=eval(  sprintf( ['unix(''ls -1 ' ...
                    filename_start '_' '??' '_?' '_' '%05i' '_' '%07i' '.d'')'],ranknb,ind ) );
                filename = liste(end-(21+length(filename_start)):end-1);
                clear(liste);
                verbose=true;
            else
                filename = sprintf( [filename_start ...
                '_' '%02i' '_' '%1i' '_' '%05i' '_' '%07i' '.d'],num_slice,dir_slice,ranknb,ind) ;
            end
    end        
end

%--- Summarize 
if verbose
    disp( [ 'Reading file : ' filename ]) 
    eval(['ls -l ' filename])
end

%--- Define precision    
int_prec ='*integer*4'; % The first star forces the variables
real_prec ='*real*4';   % to be with the same precision in matlab
double_prec ='*real*8'; % than in the stored format.    


%--- Open the file
fid = fopen(filename,'r','b'); % it is a read-only file and big endian.
if fid < 0 
    error(['Cannot open : ' filename])
end
%--- Check version number
i_version=fread(fid,1,int_prec); % get version number 
if i_version > 0 % trick to track down very old sunfluidh data files
    i_version = -1; %
end

%%% READING THE HEADER

switch i_version
    case -1
        error('Use read_sunfluid_data_old')
    case -2
        switch filename_start
            
            case 'res'
                %---
                nvar=fread(fid,1,int_prec); % Number of fields recorded
                nbr_header=fread(fid,1,int_prec);
                %--- skip nvar+nbr_header integer (array needed in fortran only)
                [~]=fread(fid,(nvar+nbr_header),int_prec);
                %--- read grid parameters
                nx=fread(fid,1,int_prec);
                ny=fread(fid,1,int_prec);
                nz=fread(fid,1,int_prec);
                %--- read data precision of the fields
                i_prec=fread(fid,1,int_prec);
                switch i_prec
                    case 1
                        float_prec = real_prec;
                    case 2
                        float_prec = double_prec;
                    otherwise
                        error('Precision of the fields is incorrectly set')
                end
                %--- Prob type
                ityppb=fread(fid,1,int_prec);
                %--- other variables
                icyl=fread(fid,1,int_prec);
                if verbose
                    disp(['Coordinate syst choice : ',num2str(icyl)])
                end
                ivelcenter=fread(fid,1,int_prec);
                if ivelcenter==1 % the fields are already centered by sunfluidh
                    centered = true;
                end
                % Maximum number of fields
                nvarmax=fread(fid,1,int_prec);
                %--- logical variables to know which fields are recorded
                kle_ch = fread(fid,nvarmax,'int32');
                % Trick to make sure kle_ch to be logical
                kle_ch = ~( kle_ch == zeros(size(kle_ch)) );
                %--- list names of variables
                list_varname=fread(fid,nvar*6,'*char')';
                %--- read time
                field.time=fread(fid,1,float_prec);
                
                %--- Reynolds and Rayleigh numbers
                Rey=fread(fid,1,float_prec)';
                Ray=fread(fid,1,float_prec);
                
            case 'rst'
                %--- Statistics are always double precision
                float_prec = double_prec;
                %---
                nvar=fread(fid,1,int_prec); % Number of fields recorded
                nbr_header=fread(fid,1,int_prec);
                %--- skip nvar+nbr_header integer (array needed in fortran only)
                [~]=fread(fid,(nvar+nbr_header),int_prec);
                %--- read grid parameters
                nx=fread(fid,1,int_prec);
                ny=fread(fid,1,int_prec);
                nz=fread(fid,1,int_prec);
                %--- read "If" flag to see there is a spatial mean of stat fields
                i_prof=fread(fid,1,int_prec);
                if i_prof > 0
                    error(['read_sunfluidh_data only reads entire ' ...
                        'fields not spatial average ' ...
                        ': Change your input3d.dat'])
                end
                %--- Cartesian/Cylindrical coordinates flag
                icyl=fread(fid,1,int_prec);
                if verbose
                    disp(['Coordinate syst choice : ',num2str(icyl)])
                end
                %--- other variables : sample numbers ,total sample number
                [~] = fread(fid,1,int_prec); %
                [~] = fread(fid,1,int_prec); %
                % Maximum number of fields
                nvarmax=fread(fid,1,int_prec);
                %--- logical variables to know which fields are recorded
                kle_ch=fread(fid,nvarmax,int_prec);
                % Trick to make sure kle_ch to be logical
                kle_ch = ~( kle_ch == zeros(size(kle_ch)) );
                 
                %--- list names of variables
                list_varname=fread(fid,nvar*6,'*char')';
                list_varname=strrep(list_varname,'<',' ');  % Ugly trick to remove < and >
                list_varname=strrep(list_varname,'>',' ');  % from varnames.
                %--- read window time
                field.window_t  = fread(fid,1,float_prec);
                [~]  = fread(fid,1,float_prec);
                
                %--- Reynolds and Rayleigh numbers
                Rey=fread(fid,1,float_prec)';Ray=fread(fid,1,float_prec);
                
                
            case 'slice'
                %---
                nvar=fread(fid,1,int_prec); % Number of fields recorded
                nbr_max_snapshots=fread(fid,1,int_prec);
                nbr_header=fread(fid,1,int_prec);
                %--- skip pl_size= nbr_header + (nvar+1)*nbr_max_snapshots integer (array needed in fortran only)
                [~]=fread(fid,(nbr_header+(nvar+1)*nbr_max_snapshots),int_prec);
                %--- read slice direction and location
                dir_slice=fread(fid,1,int_prec);
                ind_slice=fread(fid,1,int_prec);
                %--- read grid parameters
                nx=fread(fid,1,int_prec);
                ny=fread(fid,1,int_prec);
                nz=fread(fid,1,int_prec);
                %--- read data precision of the fields
                i_prec=fread(fid,1,int_prec);
                switch i_prec
                    case 1
                        float_prec = real_prec;
                    case 2
                        float_prec = double_prec;
                    otherwise
                        error('Precision of the fields is incorrectly set')
                end
                %--- Prob type
                ityppb=fread(fid,1,int_prec);
                %--- other variables
                icyl=fread(fid,1,int_prec);
                if verbose
                    disp(['Coordinate syst choice : ',num2str(icyl)])
                end
                ivelcenter=fread(fid,1,int_prec);
                if ivelcenter==1 % the fields are already centered by sunfluidh
                    centered = true;
                end
                %--- list names of variables
                list_varname=fread(fid,nvar*6,'*char')';
                %--- read iteration time (not used)
                time_iter=fread(fid,1,int_prec);
                
                %--- Reynolds and Rayleigh numbers
                Rey=fread(fid,1,float_prec)';
                Ray=fread(fid,1,float_prec);
        end
        % This is common to all files for case -2
        %--- Read grid center coordinates
        field.xc=fread(fid,nx,float_prec);
        field.yc=fread(fid,ny,float_prec);
        field.zc=fread(fid,nz,float_prec);
        
        %--- Read number of snapshots and time (only for slice)
        if strcmp(filename_start, 'slice')
            nbr_snapshots=fread(fid,1,int_prec);
            if nbr_snapshots > 1
                warning(['The current version of the script '...
                    ' reads only the first snapshot of the file']);
            end
            field.time=fread(fid,1,float_prec);
        end       
        
    case -3
        %---
        nvar=fread(fid,1,int_prec); % Number of fields recorded
        nbr_header=fread(fid,1,int_prec);
        %--- skip nvar+nbr_header integer (array needed in fortran only)
        %--- Beware that the *2 below is a dirty trick because Yann F changed
        %--- to integer*8 the array instead of integer*4 in previous version 
        [~]=fread(fid,(nvar+nbr_header)*2,int_prec);
        %--- read grid parameters
        nx=fread(fid,1,int_prec);
        ny=fread(fid,1,int_prec);
        nz=fread(fid,1,int_prec);
        %--- read data precision of the fields
        i_prec=fread(fid,1,int_prec);
        switch i_prec
            case 1
                float_prec = real_prec;
            case 2
                float_prec = double_prec;
            otherwise
                error('Precision of the fields is incorrectly set')
        end
        icyl=fread(fid,1,int_prec);
        if verbose
            disp(['Coordinate syst choice : ',num2str(icyl)])
        end
        %--- Prob type
        % ityppb=fread(fid,1,int_prec);
        
        ivelcenter=fread(fid,1,int_prec);
        if ivelcenter==1 % the fields are already centered by sunfluidh
            centered = true;
        end
        %--- list names of variables
        list_varname=fread(fid,nvar*6,'*char')';
        list_varname=strrep(list_varname,'<',' ');  % Ugly trick to remove < and >
        list_varname=strrep(list_varname,'>',' ');  % from varnames.
        %--- read time
        field.time=fread(fid,1,float_prec);
        %--- Read grid center coordinates
        field.xc=fread(fid,nx,float_prec);
        field.yc=fread(fid,ny,float_prec);
        field.zc=fread(fid,nz,float_prec);
        switch filename_start
            case 'slice'
                %--- read slice direction and location
                dir_slice=fread(fid,1,int_prec);
                ind_slice=fread(fid,1,int_prec);
                
            case 'res'
                
            case 'rst'
                %--- read "If" flag to see there is a spatial mean of stat fields
                i_prof=fread(fid,1,int_prec);
                if i_prof > 0
                    error(['read_sunfluidh_data only reads entire ' ...
                        'fields not spatial average ' ...
                        ': Change your input3d.dat'])
                end
                %--- other variables : sample numbers ,total sample number
                field.Sample_number = fread(fid,1,int_prec); %
                field.Range_number  = fread(fid,1,int_prec); %
                
                %--- read window time
                field.window_t  = fread(fid,1,float_prec);
                %[~]  = fread(fid,1,float_prec);
        end
        
    otherwise
        error(['Version mismatch or not yet implemented. Version = ', abs(i_version) ...
            sprintf('\nA possible problem is that you did not compile sunfluidh with big endian option') ] )
end
%%%  THE HEADER is read

% READING THE FIELDS
%--- Read fields. The field name is changed
%    by genvarname if needed. (ex : '<' or '>' are not valid characters)
for indvar = 1:6:6*nvar
    fieldname = genvarname(strtrim(list_varname(indvar:indvar+5))); 
    field.(fieldname)=reshape(fread(fid,nx*ny*nz,float_prec),[nx ny nz]);
end

fclose(fid);

%--- Remove dummy cells for staggered fields
if strcmp(filename_start,'res') && not(Do_centering)
    %--- Not very clean here because
    %    we assume that in the list_varname U,V,W
    %    must have these specific names.
    indchar = 1;
    for indvar = 1:nvar
      name_fieldtrim = strtrim(list_varname(indchar:indchar+5));
      name_field = list_varname(indchar:indchar+5);
%        if (kle_ch(indvar) && all(name_field == 'U     '))
        if (all(name_field == 'U     '))
            %--- remove dummy cells for U
            field.(name_fieldtrim)(nx,:,:) = [];
%        elseif (kle_ch(indvar) && all(name_field == 'V     '))
        elseif (all(name_field == 'V     '))
            %--- remove dummy cells for V
            field.(name_fieldtrim)(:,ny,:) = [];
%        elseif (kle_ch(indvar) && all(name_field == 'W     ') && nz >1)
        elseif (all(name_field == 'W     ') && nz >1)
            %--- remove dummy cells for W
            field.(name_fieldtrim)(:,:,nz) = [];
            % else  % other special fields
        end
        indchar = indchar+6;
    end
end

%--- Interpolate staggered fields on xc,yc,zc coordinates
if strcmp(filename_start,'res') && Do_centering
    %--- Not very clean here because
    %    we assume that in the list_varname U,V,W
    %    must have these specific names.
    indchar = 1;
    for indvar = 1:nvar
        name_field = list_varname(indchar:indchar+5);
        name_fieldtrim = strtrim(name_field);
%        if (kle_ch(indvar) && all(name_field == 'U     ') && nx >2)
        if (all(name_field == 'U     ') && nx >2)
            %--- copy last cells to dummy cells
            field.(name_fieldtrim)(nx,:,:) = field.(name_fieldtrim)(nx-1,:,:);
            %--- interpolation for U
            field.(name_fieldtrim)(2:nx-1,:,:) = ...
                (field.(name_fieldtrim)(1:nx-2,:,:)+field.(name_fieldtrim)(2:nx-1,:,:) )/2;
%        elseif (kle_ch(indvar) && all(name_field == 'V     ') && ny >2)
        elseif (all(name_field == 'V     ') && ny >2)
            %--- copy last cells to dummy cells
            field.(name_fieldtrim)(:,ny,:) = field.(name_fieldtrim)(:,ny-1,:);
            %--- interpolation for V
            field.(name_fieldtrim)(:,2:ny-1,:) = ...
                (field.(name_fieldtrim)(:,1:ny-2,:)+field.(name_fieldtrim)(:,2:ny-1,:))/2;
%        elseif (kle_ch(indvar) && all(name_field == 'W     ') && nz>2)
        elseif (all(name_field == 'W     ') && nz>2)
            %--- copy last cells to dummy cells
            field.(name_fieldtrim)(:,:,nz) = field.(name_fieldtrim)(:,:,nz-1);
            %--- interpolation for W
            field.(name_fieldtrim)(:,:,2:nz-1) = ...
                (field.(name_fieldtrim)(:,:,1:nz-2) + ...
                field.(name_fieldtrim)(:,:,2:nz-1) )/2;
        end
        indchar = indchar+6;
    end
    centered = true;
end

%--- generates staggered grid if staggered fields are in the output
if (not(centered))
field.xu=cent2stag(field.xc);
field.yv=cent2stag(field.yc);
field.zw=cent2stag(field.zc);
end

%---Nested function
function [ xi ] = cent2stag(xc)
%CENT2STAG convert centered grid vector to interface
%   The vector is supposed to be stored  
%   monotonically.

      
if max(size(xc)) == 1
    xi = xc;
    return
end

xi = 0*xc; % In order to have a vector of same length
xi(end) =[]; % Remove last element
xi(1) = (xc(1)+xc(2))/2;   
for k = 2:length(xi) 
    xi(k) = 2*xc(k) - xi(k-1);
end


end

end
